{"version":3,"sources":["../../src/pg/citext/custom-types.ts","../../src/pg/cube/custom-types.ts","../../src/pg/cube/functions.ts","../../src/pg/cube/constants.ts","../../src/pg/cube/operators.ts","../../src/pg/fuzzystrmatch/functions.ts","../../src/pg/pgcrypto/functions.ts","../../src/pg/pgtrgm/operators.ts","../../src/pg/postgis/constants.ts","../../src/pg/postgis/custom-types.ts","../../src/pg/constants.ts","../../src/pg/internals.ts","../../src/pg/custom-types.ts","../../src/values.ts","../../src/pg/functions.ts","../../src/pg/operators.ts","../../src/internals.ts","../../src/pg/utilities.ts","../../src/pg/validation.ts","../../src/pg/values.ts"],"names":["citext","customType","cube","value","makeCube","args","params","sql","c","StringChunk","cubeDim","cubeLowerLeftCoord","cubeUpperRightCoord","cubeIsPoint","cubeDistance","cubes","cubeSubset","cubeUnion","cubeInter","cubeEnlarge","DISTANCE_TYPES","DISTANCE_TYPES_OPERATORS","overlaps","left","right","bindIfParam","contains","contained","extract","distance","type","soundex","text","difference","texts","daitch_mokotoff","source","nanoid","optimized","size","alphabet","additionalBytesFactor","mask","step","fname","similar","SRIDS","geography","name","config","z","m","srid","parsed","err","geometry","REGCONFIGS","RANGE_BOUND_TYPES","RANGE_EMPTY","INTERVAL_UNITS","INTERVAL_UNITS_ARR_ORDERED","RANGE_BOUND_BRACKETS","textenum","isEnumMember","regconfig","tsvector","tsrange","h","parseDate","lower","upper","lb","ub","daterange","intrange","numrange","random","now","boolAnd","expression","boolOr","jsonStripNulls","json","arrayAgg","toJson","anyelement","toJsonb","rowToJson","row","jsonBuildObject","shape","chunks","key","jsonbBuildObject","jsonAggBuildObject","distinct","jsonObjectAgg","jsonbObjectAgg","jsonAgg","selection","notNull","getCurrentTsConfig","toTsvector","isSQLWrapper","toTsquery","plain","start","end","SQL","setweight","weight","char","age","origin","target","isEmpty","range","ts","vector","querytext","PG_DIALECT","PgDialect","toExcluded","columns","acc","curr","generatedTsvector","cfgname","input","index","toInterval","units","toRange","tuple","lowerBound","upperBound","intrangeSchema","min","max","baseSchema","lowerSchema","upperSchema","numrangeSchema","dateToString","date","withTimezone","tzOffset","tsrangeSchema","mode","infinitySchema","toMode","d","daterangeSchema","$emptyJsonObject","$emptyJsonArray","$emptyArray","$nullArray","$empty"],"mappings":"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","file":"index.cjs","sourcesContent":["import { customType } from 'drizzle-orm/pg-core';\n\n/**\n * Ci-text postgres column type.\n *\n * @see https://www.postgresql.org/docs/current/citext.html\n */\nexport const citext = customType<{ data: string }>({\n\tdataType() {\n\t\treturn `citext`;\n\t},\n});\n","import { customType } from 'drizzle-orm/pg-core';\n\n/**\n * Postgres cube column type with customizable amount of dimensions.\n *\n * @see https://www.postgresql.org/docs/current/cube.html\n */\nexport const cube = customType<{\n\tdata: number[] | [number[], number[]];\n\tdriverData: number[] | [number[], number[]];\n}>({\n\tdataType() {\n\t\treturn `cube`;\n\t},\n\tfromDriver(value) {\n\t\treturn value;\n\t},\n\ttoDriver(value) {\n\t\treturn value;\n\t},\n});\n","// https://www.postgresql.org/docs/current/cube.html#CUBE-FUNCTIONS-TABLE\n\nimport type { SQLWrapper } from 'drizzle-orm';\nimport { StringChunk, sql } from 'drizzle-orm';\n\n/**\n * Makes a one dimensional cube with both coordinates the same.\n *\n * @example\n *\n * ```sql\n * -- cube ( float8 ) → cube\n * cube(1) → (1)\n * ```\n *\n * Makes a one dimensional cube.\n *\n * @example\n *\n * ```sql\n * -- cube ( float8, float8 ) → cube\n * cube(1, 2) → (1),(2)\n * ```\n *\n * Makes a zero-volume cube using the coordinates defined by the array.\n *\n * @example\n *\n * ```sql\n * -- cube ( float8[] ) → cube\n * cube(ARRAY[1,2,3]) → (1, 2, 3)\n * ```\n *\n * Makes a cube with upper right and lower left coordinates as defined by the two arrays, which must\n * be of the same length.\n *\n * @example\n *\n * ```sql\n * -- cube ( float8[], float8[] ) → cube\n * cube(ARRAY[1,2], ARRAY[3,4]) → (1, 2),(3, 4)\n * ```\n *\n * Makes a new cube by adding a dimension on to an existing cube, with the same values for both\n * endpoints of the new coordinate. This is useful for building cubes piece by piece from calculated\n * values.\n *\n * @example\n *\n * ```sql\n * -- cube ( cube, float8 ) → cube\n * cube('(1,2),(3,4)'::cube, 5) → (1, 2, 5),(3, 4, 5)\n * ```\n *\n * Makes a new cube by adding a dimension on to an existing cube. This is useful for building cubes\n * piece by piece from calculated values.\n *\n * @example\n *\n * ```sql\n * --cube ( cube, float8, float8 ) → cube\n * cube('(1,2),(3,4)'::cube, 5, 6) → (1, 2, 5),(3, 4, 6)\n * ```\n */\nexport function makeCube<\n\tT extends\n\t\t| [number]\n\t\t| [number, number]\n\t\t| number[]\n\t\t| [number[], number[]]\n\t\t| [SQLWrapper, number]\n\t\t| [SQLWrapper, number, number],\n>(...args: T) {\n\tconst params = sql.join(\n\t\targs.map((c) => sql`${c}`),\n\t\tnew StringChunk(',')\n\t);\n\treturn sql<number[]>`cube(${params})`;\n}\n\n/**\n * Returns the number of dimensions of the cube.\n *\n * @example\n *\n * ```sql\n * --cube_dim ( cube ) → integer\n * cube_dim('(1,2),(3,4)') → 2\n * ```\n */\nexport function cubeDim(cube: SQLWrapper) {\n\treturn sql`cube_dim(${cube})`.mapWith(Number);\n}\n\n/**\n * Returns the n-th coordinate value for the lower left corner of the cube.\n *\n * @example\n *\n * ```sql\n * -- cube_ll_coord ( cube, integer ) → float8\n * cube_ll_coord('(1,2),(3,4)', 2) → 2\n * ```\n */\nexport function cubeLowerLeftCoord() {}\n\n/**\n * ```\n * Returns the n-th coordinate value for the upper right corner of the cube.\n * ```\n *\n * @example\n *\n * ```sql\n * -- cube_ur_coord ( cube, integer ) → float8\n * cube_ur_coord('(1,2),(3,4)', 2) → 4\n * ```\n */\nexport function cubeUpperRightCoord() {}\n\n/**\n * Returns true if the cube is a point, that is, the two defining corners are the same.\n *\n * @example\n *\n * ```sql\n * -- cube_is_point ( cube ) → boolean\n * cube_is_point(cube(1,1)) → t\n * ```\n */\nexport function cubeIsPoint(cube: SQLWrapper) {\n\treturn sql`cube_is_point(${cube})`.mapWith(Boolean);\n}\n\n/**\n * Returns the distance between two cubes. If both cubes are points, this is the normal distance\n * function.\n *\n * @example\n *\n * ```sql\n * -- cube_distance ( cube, cube ) → float8\n * cube_distance('(1,2)', '(3,4)') → 2.8284271247461903\n * ```\n */\nexport function cubeDistance(...cubes: [SQLWrapper, SQLWrapper]) {\n\tconst params = sql.join(cubes, new StringChunk(','));\n\treturn sql`cube_distance(${params})`.mapWith(Number);\n}\n\n/**\n * Makes a new cube from an existing cube, using a list of dimension indexes from an array. Can be\n * used to extract the endpoints of a single dimension, or to drop dimensions, or to reorder them as\n * desired.\n *\n * @example\n *\n * ```sql\n * cube_subset ( cube, integer[] ) → cube\n * cube_subset(cube('(1,3,5),(6,7,8)'), ARRAY[2]) → (3),(7)\n * cube_subset(cube('(1,3,5),(6,7,8)'), ARRAY[3,2,1,1]) → (5, 3, 1, 1),(8, 7, 6, 6)\n * ```\n */\nexport function cubeSubset() {}\n\n/**\n * Produces the union of two cubes.\n *\n * @example\n *\n * ```sql\n * -- cube_union ( cube, cube ) → cube\n * cube_union('(1,2)', '(3,4)') → (1, 2),(3, 4)\n * ```\n */\nexport function cubeUnion() {}\n\n/**\n * Produces the intersection of two cubes.\n *\n * @example\n *\n * ```sql\n * -- cube_inter ( cube, cube ) → cube\n * cube_inter('(1,2)', '(3,4)') → (3, 4),(1, 2)\n * ```\n */\nexport function cubeInter() {}\n\n/**\n * Increases the size of the cube by the specified radius r in at least n dimensions. If the radius\n * is negative the cube is shrunk instead. All defined dimensions are changed by the radius r.\n * Lower-left coordinates are decreased by r and upper-right coordinates are increased by r. If a\n * lower-left coordinate is increased to more than the corresponding upper-right coordinate (this\n * can only happen when r < 0) than both coordinates are set to their average. If n is greater than\n * the number of defined dimensions and the cube is being enlarged (r > 0), then extra dimensions\n * are added to make n altogether; 0 is used as the initial value for the extra coordinates. This\n * function is useful for creating bounding boxes around a point for searching for nearby points.\n *\n * @example\n *\n * ```sql\n * -- cube_enlarge ( c cube, r double, n integer ) → cube\n * cube_enlarge('(1,2),(3,4)', 0.5, 3) → (0.5, 1.5, -0.5),(3.5, 4.5, 0.5)\n * ```\n */\nexport function cubeEnlarge() {}\n","import type { ValueOf } from 'type-fest';\n\nexport const DISTANCE_TYPES = {\n\tEUCLIDIAN: 'euclidian',\n\tTAXICAB: 'taxicab',\n\tCHEBYSHEV: 'chebyshev',\n} as const;\nexport type DistanceType = ValueOf<typeof DISTANCE_TYPES>;\n\nexport const DISTANCE_TYPES_OPERATORS = {\n\t[DISTANCE_TYPES.EUCLIDIAN]: '<->',\n\t[DISTANCE_TYPES.TAXICAB]: '<#>',\n\t[DISTANCE_TYPES.CHEBYSHEV]: '<=>',\n} as const satisfies Record<DistanceType, string>;\n","// https://www.postgresql.org/docs/current/cube.html#CUBE-OPERATORS-TABLE\n\nimport type { SQLWrapper } from 'drizzle-orm';\nimport { bindIfParam, sql } from 'drizzle-orm';\nimport type { DistanceType } from './constants';\nimport { DISTANCE_TYPES, DISTANCE_TYPES_OPERATORS } from './constants';\n\n/**\n * Do the cubes overlap?\n *\n * @example\n *\n * ```sql\n * cube && cube → boolean\n * ```\n */\nexport function overlaps(left: SQLWrapper, right: unknown) {\n\treturn sql`${left} && ${bindIfParam(right, left)}`;\n}\n\n/**\n * Does the first cube contain the second?\n *\n * @example\n *\n * ```sql\n * cube @> cube → boolean\n * ```\n */\nexport function contains(left: SQLWrapper, right: unknown) {\n\treturn sql`${left} @> ${bindIfParam(right, left)}`;\n}\n\n/**\n * Is the first cube contained in the second?\n *\n * @example\n *\n * ```sql\n * cube <@ cube → boolean\n * ```\n */\nexport function contained(left: SQLWrapper, right: unknown) {\n\treturn sql`${left} <@ ${bindIfParam(right, left)}`;\n}\n\n/**\n * Extracts the n-th coordinate of the cube (counting from 1).\n *\n * @example\n *\n * ```sql\n * cube -> integer → float8\n * ```\n *\n * Extracts the n-th coordinate of the cube, counting in the following way: n = 2 * k - 1 means\n * lower bound of k-th dimension, n = 2 * k means upper bound of k-th dimension. Negative n denotes\n * the inverse value of the corresponding positive coordinate. This operator is designed for\n * KNN-GiST support.\n *\n * @example\n *\n * ```sql\n * cube ~> integer → float8\n * ```\n */\nexport function extract(left: SQLWrapper, right: unknown) {\n\treturn sql`${left} -> ${bindIfParam(right, left)}`;\n}\n\n/**\n * Computes the distance between two cubes.\n *\n * @example\n *\n * ```sql\n * -- Computes the Euclidean distance between the two cubes.\n * cube <-> cube → float8\n * ```\n *\n * @example\n *\n * ```sql\n * -- Computes the taxicab (L-1 metric) distance between the two cubes.\n * cube <#> cube → float8\n * ```\n *\n * @example\n *\n * ```sql\n * -- Computes the Chebyshev (L-inf metric) distance between the two cubes.\n * cube <=> cube → float8\n * ```\n */\nexport function distance(\n\tleft: SQLWrapper,\n\tright: unknown,\n\t{ type = DISTANCE_TYPES.EUCLIDIAN }: { type?: DistanceType } = {}\n) {\n\treturn sql`${left} ${DISTANCE_TYPES_OPERATORS[type]} ${bindIfParam(right, left)}`;\n}\n","import type { SQLWrapper } from 'drizzle-orm';\nimport { sql } from 'drizzle-orm';\n\n/**\n * @see https://www.postgresql.org/docs/current/fuzzystrmatch.html#FUZZYSTRMATCH-SOUNDEX\n */\nexport function soundex(text: string | SQLWrapper) {\n\treturn sql`soundex(${text})`.mapWith(String);\n}\n\n/**\n * @see https://www.postgresql.org/docs/current/fuzzystrmatch.html#FUZZYSTRMATCH-DAITCH-MOKOTOFF\n */\nexport function difference(...texts: [string | SQLWrapper, string | SQLWrapper]) {\n\treturn sql`difference(${texts[0]}, ${texts[1]})`.mapWith(Number);\n}\n\n/**\n * @see https://www.postgresql.org/docs/current/fuzzystrmatch.html#FUZZYSTRMATCH-DAITCH-MOKOTOFF\n */\nexport function daitch_mokotoff(source: SQLWrapper | string) {\n\treturn sql<string[]>`daitch_mokotoff(${source})`;\n}\n","import { sql } from 'drizzle-orm';\n\n/**\n * Generate a nanoid using a postgres implementation of the nanoid function.\n *\n * @param config.optimized Should the postgres extension use optimization.\n * @param config.size The length of the nanoid generated. If explicit nullish is passed, will\n *   default to the Postgres function's default size.\n * @param config.alphabet The set of characters to pick randomly from. Defaults to\n *   '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'. If explicit nullish is\n *   passed, will default to the Postgres function's default alphabet.\n * @param config.additionalBytesFactor\n * @param config.mask\n * @param config.step\n * @see {@link https://github.com/iolyd/drizzle-orm-helpers/blob/main/sql/nanoid.sql Postgres implementation of the nanoid generator}\n * @see https://discord.com/channels/1043890932593987624/1093946807911989369/1100459226087825571\n * @todo Stay up to date when default values will accept 'sql' without having to pass param to\n *   sql.raw()\n */\nexport function nanoid({\n\toptimized,\n\tsize,\n\talphabet,\n\tadditionalBytesFactor,\n\tmask,\n\tstep,\n}: {\n\tsize?: number;\n\talphabet?: string;\n} & (\n\t| {\n\t\t\toptimized?: false;\n\t\t\tadditionalBytesFactor?: number;\n\t\t\tmask?: never;\n\t\t\tstep?: never;\n\t  }\n\t| {\n\t\t\toptimized: true;\n\t\t\tadditionalBytesFactor?: never;\n\t\t\tmask?: number;\n\t\t\tstep?: number;\n\t  }\n) = {}) {\n\tconst params: string[] = [];\n\tif (size) {\n\t\tparams.push(`size => ${size}`);\n\t}\n\tif (alphabet) {\n\t\tparams.push(`alphabet => '${alphabet}'`);\n\t}\n\tif (additionalBytesFactor) {\n\t\tparams.push(`additionalBytesFactor => ${additionalBytesFactor}`);\n\t}\n\tif (mask) {\n\t\tparams.push(`mask => ${mask}`);\n\t}\n\tif (step) {\n\t\tparams.push(`step => ${step}`);\n\t}\n\tconst fname = optimized ? 'nanoid_optimized' : 'nanoid';\n\t// return new SQL([\n\t// \tnew StringChunk(`${getSchemaPrefix.call(this)}${fname}(`),\n\t// \tsql.join(chunks, new StringChunk(', ')),\n\t// \tnew StringChunk(')'),\n\t// ]).mapWith(String);\n\treturn sql.raw(`${fname}(${params.join(',')})`).mapWith(String);\n}\n","// text % text → boolean\n// Returns true if its arguments have a similarity that is greater than the current similarity threshold set by pg_trgm.similarity_threshold.\nexport function similar() {}\n\n// text <% text → boolean\n// Returns true if the similarity between the trigram set in the first argument and a continuous extent of an ordered trigram set in the second argument is greater than the current word similarity threshold set by pg_trgm.word_similarity_threshold parameter.\n\n// text %> text → boolean\n// Commutator of the <% operator.\n\n// text <<% text → boolean\n// Returns true if its second argument has a continuous extent of an ordered trigram set that matches word boundaries, and its similarity to the trigram set of the first argument is greater than the current strict word similarity threshold set by the pg_trgm.strict_word_similarity_threshold parameter.\n\n// text %>> text → boolean\n// Commutator of the <<% operator.\n\n// text <-> text → real\n// Returns the “distance” between the arguments, that is one minus the similarity() value.\n\n// text <<-> text → real\n// Returns the “distance” between the arguments, that is one minus the word_similarity() value.\n\n// text <->> text → real\n// Commutator of the <<-> operator.\n\n// text <<<-> text → real\n// Returns the “distance” between the arguments, that is one minus the strict_word_similarity() value.\n\n// text <->>> text → real\n// Commutator of the <<<-> operator.\n","import type { ValueOf } from 'type-fest';\n\n/**\n * Common coordinate projection systems and their Spatial Reference System ID (EPSG).\n *\n * @example\n *\n * ```sql\n * SELECT * FROM extensions.spatial_ref_sys;\n * ```\n *\n * @todo Add more aliased systems.\n */\nexport const SRIDS = {\n\t/**\n\t * Lat/Lon globe-based coordinate system. Uses degrees to represent spheroid position.\n\t */\n\tWGS84: 4326,\n\t/**\n\t * Lat/Lon flat-map coordinates in meters. Generally the default system used for web apps.\n\t */\n\tWEB_MERCATOR: 3857,\n} as const;\nexport type Srid = ValueOf<typeof SRIDS> | `${ValueOf<typeof SRIDS>}`;\n","import { customType } from 'drizzle-orm/pg-core';\nimport type { GeoJsonGeometryTypes, Geometry } from 'geojson';\nimport { SRIDS, type Srid } from './constants';\n\n/**\n * PostGIS column type for generic or specific geographies.\n *\n * **⚠️ Warning ⚠️**\n *\n * Uses a nasty trick to get the data back as properly formatted GeoJSON rather than WKT. Expect\n * things to break.\n *\n * @see Unstable until better support for custom type custom select is available (e.g. https://github.com/drizzle-team/drizzle-orm/pull/1423)\n */\nexport function geography<\n\tTName extends string,\n\tTGeography extends GeoJsonGeometryTypes,\n\tTZ extends boolean,\n\tTM extends boolean,\n\tTSrid extends Srid,\n>(name: TName, config?: { type?: TGeography; z?: TZ; m?: TM; srid?: TSrid }) {\n\tconst z = config?.z ? 'Z' : '';\n\tconst m = config?.m ? 'M' : '';\n\tconst srid = config?.srid ? `,${config.srid}` : '';\n\tconst basetype = config?.type ? config.type : z || m || srid ? 'Geography' : '';\n\tconst type = `${basetype}${z}${m}`;\n\treturn customType<{\n\t\tdata: Extract<Geometry, { type: TGeography }>;\n\t\tdriverData: string;\n\t\tconfig: typeof config;\n\t}>({\n\t\tdataType() {\n\t\t\tconst paren = type ? `(${type}${srid})` : '';\n\t\t\treturn `geography${paren}`;\n\t\t},\n\t\ttoDriver(value) {\n\t\t\treturn `st_transform(st_geomfromgeojson(${JSON.stringify(value)}),${srid ?? SRIDS.WEB_MERCATOR})::geography`;\n\t\t},\n\t\tfromDriver(value) {\n\t\t\ttry {\n\t\t\t\tconst parsed = JSON.parse(value);\n\t\t\t\tif (config?.type && parsed.type !== config.type) {\n\t\t\t\t\tthrow new Error(`Expected geography type ${config.type}, got ${parsed.type}`);\n\t\t\t\t}\n\t\t\t\treturn parsed;\n\t\t\t} catch (err) {\n\t\t\t\tthrow new Error(`Failed to parse geography`, {\n\t\t\t\t\tcause: err,\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t})(`st_asgeojson\"(\"${name}\") as \"${name}`, config);\n}\n\n/**\n * - PostGIS column type for generic or specific geometries.\n *\n * **⚠️ Warning ⚠️**\n *\n * Uses a nasty trick to get the data back as properly formatted GeoJSON rather than WKT. Expect\n * things to break.\n *\n * @see Unstable until better support for custom type custom select is available (e.g. https://github.com/drizzle-team/drizzle-orm/pull/1423)\n */\nexport function geometry<\n\tTName extends string,\n\tTGeometry extends GeoJsonGeometryTypes,\n\tTZ extends boolean,\n\tTM extends boolean,\n\tTSrid extends Srid,\n>(name: TName, config?: { type?: TGeometry; z?: TZ; m?: TM; srid?: TSrid }) {\n\tconst z = config?.z ? 'Z' : '';\n\tconst m = config?.m ? 'M' : '';\n\tconst srid = config?.srid ? `,${config.srid}` : '';\n\tconst basetype = config?.type ? config.type : z || m || srid ? 'Geography' : '';\n\tconst type = `${basetype}${z}${m}`;\n\treturn customType<{\n\t\tdata: Extract<Geometry, { type: TGeometry }>;\n\t\tdriverData: string;\n\t\tconfig: typeof config;\n\t}>({\n\t\tdataType() {\n\t\t\tconst paren = type ? `(${type}${srid})` : '';\n\t\t\treturn `geometry${paren}`;\n\t\t},\n\t\ttoDriver(value) {\n\t\t\treturn `st_transform(st_geomfromgeojson(${JSON.stringify(value)}),${srid ?? SRIDS.WEB_MERCATOR})::geometry`;\n\t\t},\n\t\tfromDriver(value) {\n\t\t\ttry {\n\t\t\t\tconst parsed = JSON.parse(value);\n\t\t\t\tif (config?.type && parsed.type !== config.type) {\n\t\t\t\t\tthrow new Error(`Expected geometry type ${config.type}, got ${parsed.type}`);\n\t\t\t\t}\n\t\t\t\treturn parsed;\n\t\t\t} catch (err) {\n\t\t\t\tthrow new Error(`Failed to parse geometry`, {\n\t\t\t\t\tcause: err,\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t})(`st_asgeojson\"(\"${name}\") as \"${name}`, config);\n}\n","import type { ValueOf } from 'type-fest';\nimport type { RangeValue } from '.';\n\n/**\n * Postgres regconfig cfgnames.\n *\n * @example\n *\n * ```sql\n * SELECT json_object_agg(upper(cfgname), cfgname)\n * FROM pg_catalog.pg_ts_config;\n * ```\n */\nexport const REGCONFIGS = {\n\tSIMPLE: 'simple',\n\tARABIC: 'arabic',\n\tARMENIAN: 'armenian',\n\tBASQUE: 'basque',\n\tCATALAN: 'catalan',\n\tDANISH: 'danish',\n\tDUTCH: 'dutch',\n\tENGLISH: 'english',\n\tFINNISH: 'finnish',\n\tFRENCH: 'french',\n\tGERMAN: 'german',\n\tGREEK: 'greek',\n\tHINDI: 'hindi',\n\tHUNGARIAN: 'hungarian',\n\tINDONESIAN: 'indonesian',\n\tIRISH: 'irish',\n\tITALIAN: 'italian',\n\tLITHUANIAN: 'lithuanian',\n\tNEPALI: 'nepali',\n\tNORWEGIAN: 'norwegian',\n\tPORTUGUESE: 'portuguese',\n\tROMANIAN: 'romanian',\n\tRUSSIAN: 'russian',\n\tSERBIAN: 'serbian',\n\tSPANISH: 'spanish',\n\tSWEDISH: 'swedish',\n\tTAMIL: 'tamil',\n\tTURKISH: 'turkish',\n\tYIDDISH: 'yiddish',\n} as const;\n\nexport type Regconfig = ValueOf<typeof REGCONFIGS>;\n\nexport type RegconfigString = Regconfig | (string & NonNullable<unknown>);\n\nexport const RANGE_BOUND_TYPES = {\n\tINCLUSIVE: 'inclusive',\n\tEXCLUSIVE: 'exclusive',\n} as const;\n\nexport type RangeBoundType = ValueOf<typeof RANGE_BOUND_TYPES>;\n\n/**\n * Value for app-side representation of empty postgres ranges.\n */\nexport const RANGE_EMPTY = { lower: null, upper: null } satisfies RangeValue;\n\nexport const INTERVAL_UNITS = {\n\tYEARS: 'years',\n\tMONTHS: 'months',\n\tWEEKS: 'weeks',\n\tDAYS: 'days',\n\tHOURS: 'hours',\n\tMINUTES: 'minutes',\n\tSECONDS: 'seconds',\n} as const;\n\nexport type IntervalUnit = ValueOf<typeof INTERVAL_UNITS>;\n\nexport const INTERVAL_UNITS_ARR_ORDERED = [\n\tINTERVAL_UNITS.YEARS,\n\tINTERVAL_UNITS.MONTHS,\n\tINTERVAL_UNITS.WEEKS,\n\tINTERVAL_UNITS.DAYS,\n\tINTERVAL_UNITS.HOURS,\n\tINTERVAL_UNITS.MINUTES,\n\tINTERVAL_UNITS.SECONDS,\n] as const;\n","import { RANGE_BOUND_TYPES, type RangeBoundType } from '.';\n\nexport const RANGE_BOUND_BRACKETS = {\n\tLOWER: {\n\t\t[RANGE_BOUND_TYPES.INCLUSIVE]: '[',\n\t\t[RANGE_BOUND_TYPES.EXCLUSIVE]: '(',\n\t},\n\tUPPER: {\n\t\t[RANGE_BOUND_TYPES.INCLUSIVE]: ']',\n\t\t[RANGE_BOUND_TYPES.EXCLUSIVE]: ')',\n\t},\n} satisfies Record<'UPPER' | 'LOWER', Record<RangeBoundType, string>>;\n","import { customType } from 'drizzle-orm/pg-core';\nimport parseDate from 'postgres-date';\nimport * as range from 'postgres-range';\nimport { RANGE_EMPTY, type RangeValue } from '.';\nimport type { RangeBoundType, Regconfig } from './constants';\nimport { RANGE_BOUND_BRACKETS } from './internals';\n\n/**\n * Text-based enum with runtime check and type inferrence. In other words, similar to drizzle's own\n * `text` column with `config.enum` but this time with runtime peace-of mind.\n *\n * If you simply want a union-typed text without runtime safety of values, use drizzle's own `text`\n * with the `config.enum` configuration.\n *\n * @see https://orm.drizzle.team/docs/column-types/pg#text\n */\nexport function textenum<\n\tTName extends string,\n\tconst TEnum extends string[] | Readonly<string[]>,\n\tTConfig extends {\n\t\tenum: TEnum;\n\t\tfallback: TConfig['enum'][number] | Error | ((value: string) => TConfig['enum'][number]);\n\t},\n>(name: TName, config: TConfig) {\n\tfunction isEnumMember(value: unknown): value is TEnum[number] {\n\t\treturn config.enum.includes(value as TEnum[number]);\n\t}\n\treturn customType<{\n\t\tdata: TConfig['enum'][number];\n\t\tdriverData: string;\n\t\tconfig: TConfig;\n\t}>({\n\t\tdataType() {\n\t\t\treturn 'text';\n\t\t},\n\t\tfromDriver(value) {\n\t\t\tif (isEnumMember(value)) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (config.fallback instanceof Error) {\n\t\t\t\tthrow config.fallback;\n\t\t\t}\n\t\t\tif (typeof config.fallback === 'function') {\n\t\t\t\treturn config.fallback(value);\n\t\t\t}\n\t\t\treturn config.fallback;\n\t\t},\n\t\ttoDriver(value) {\n\t\t\tif (isEnumMember(value)) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (config.fallback instanceof Error) {\n\t\t\t\tthrow config.fallback;\n\t\t\t}\n\t\t\tif (typeof config.fallback === 'function') {\n\t\t\t\treturn config.fallback(value);\n\t\t\t}\n\t\t\treturn config.fallback;\n\t\t},\n\t})(name, config);\n}\n\n/**\n * Implements Postgres regconfig. Useful for text search language config storage.\n *\n * @see https://www.postgresql.org/docs/current/textsearch-controls.html\n */\nexport const regconfig = customType<{ data: Regconfig }>({\n\tdataType() {\n\t\treturn 'regconfig';\n\t},\n\ttoDriver(value) {\n\t\treturn `${value}`;\n\t},\n});\n\n/**\n * Postgres text-search vector.\n */\nexport const tsvector = customType<{ data: string }>({\n\tdataType() {\n\t\treturn 'tsvector';\n\t},\n});\n\n/**\n * Implements Postgres timestamp range.\n *\n * @see https://www.postgresql.org/docs/current/rangetypes.html\n * @see https://github.com/bendrucker/postgres-date\n */\nexport function tsrange<\n\tTName extends string,\n\tTConfig extends {\n\t\twithTimezone?: boolean;\n\t\tmode?: 'date' | 'string';\n\t\tlowerBound?: RangeBoundType;\n\t\tupperBound?: RangeBoundType;\n\t},\n\tTData = TConfig['mode'] extends 'string' ? RangeValue<string> : RangeValue<number | Date>,\n>(name: TName, config?: TConfig) {\n\treturn customType<{\n\t\tdata: TData;\n\t\tdriverData: string;\n\t\tconfig: TConfig;\n\t}>({\n\t\tdataType(config) {\n\t\t\tconst tz = config?.withTimezone ? 'tz' : '';\n\t\t\treturn `ts${tz}range`;\n\t\t},\n\t\tfromDriver(value) {\n\t\t\tconst parsed = range.parse(value, (value) => {\n\t\t\t\tif (config?.mode === 'string') {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\treturn parseDate(value);\n\t\t\t});\n\t\t\tif (parsed.isEmpty()) {\n\t\t\t\treturn RANGE_EMPTY as TData;\n\t\t\t}\n\t\t\treturn { lower: parsed.lower, upper: parsed.upper } as TData;\n\t\t},\n\t\ttoDriver(value) {\n\t\t\tif (value === null || typeof value !== 'object' || !('lower' in value && 'upper' in value)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Value passed to driver for range should be an object with lower and upper properties.'\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst lower = value.lower instanceof Date ? value.lower.toISOString() : value.lower ?? '';\n\t\t\tconst upper = value.upper instanceof Date ? value.upper.toISOString() : value.upper ?? '';\n\t\t\t// Using canonical form of included lower bound and excluded upper bound.\n\t\t\t// See https://www.postgresql.org/docs/current/rangetypes.html#RANGETYPES-DISCRETE\n\t\t\tconst lb = RANGE_BOUND_BRACKETS.LOWER[config?.lowerBound ?? 'inclusive'];\n\t\t\tconst ub = RANGE_BOUND_BRACKETS.UPPER[config?.upperBound ?? 'exclusive'];\n\t\t\treturn `${lb}${lower},${upper}${ub}`;\n\t\t},\n\t})(name, config);\n}\n\n/**\n * Implements postgres date range.\n *\n * @see https://orm.drizzle.team/docs/custom-types Timestamp for reference.\n * @see https://www.postgresql.org/docs/current/rangetypes.html\n */\nexport function daterange<\n\tTName extends string,\n\tTConfig extends {\n\t\tmode?: 'date' | 'string';\n\t\tlowerBound?: RangeBoundType;\n\t\tupperBound?: RangeBoundType;\n\t},\n\tTData = TConfig['mode'] extends 'string' ? RangeValue<string> : RangeValue<number | Date>,\n>(name: TName, config?: TConfig) {\n\treturn customType<{\n\t\tdata: TData;\n\t\tdriverData: string;\n\t\tconfig: TConfig;\n\t}>({\n\t\tdataType() {\n\t\t\treturn 'daterange';\n\t\t},\n\t\tfromDriver(value) {\n\t\t\tconst parsed = range.parse(value, (value) => {\n\t\t\t\tif (config?.mode === 'string') {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\treturn parseDate(value);\n\t\t\t});\n\t\t\tif (parsed.isEmpty()) {\n\t\t\t\treturn RANGE_EMPTY as TData;\n\t\t\t}\n\t\t\treturn { lower: parsed.lower, upper: parsed.upper } as TData;\n\t\t},\n\t\ttoDriver(value) {\n\t\t\tif (value === null || typeof value !== 'object' || !('lower' in value && 'upper' in value)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Value passed to driver for range should be an object with lower and upper properties.'\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst lower = value.lower instanceof Date ? value.lower.toISOString() : value.lower ?? '';\n\t\t\tconst upper = value.upper instanceof Date ? value.upper.toISOString() : value.upper ?? '';\n\t\t\t// Using canonical form of included lower bound and excluded upper bound.\n\t\t\t// See https://www.postgresql.org/docs/current/rangetypes.html#RANGETYPES-DISCRETE\n\t\t\tconst lb = RANGE_BOUND_BRACKETS.LOWER[config?.lowerBound ?? 'inclusive'];\n\t\t\tconst ub = RANGE_BOUND_BRACKETS.UPPER[config?.upperBound ?? 'exclusive'];\n\t\t\treturn `${lb}${lower},${upper}${ub}`;\n\t\t},\n\t})(name, config);\n}\n\n/**\n * Implements postgres int4range and int8range types.\n *\n * @param config.size Size of integers, where `4` corresponds to `int4range` and `8`corresponds to a\n *   bigint range (int8range).\n * @see https://www.postgresql.org/docs/current/rangetypes.html\n */\nexport function intrange<\n\tTName extends string,\n\tTConfig extends {\n\t\tsize?: 4 | 8;\n\t\tlowerBound?: RangeBoundType;\n\t\tupperBound?: RangeBoundType;\n\t},\n>(name: TName, config?: TConfig) {\n\treturn customType<{\n\t\tdata: RangeValue<number>;\n\t\tdriverData: string;\n\t\tconfig: TConfig;\n\t}>({\n\t\tdataType(config) {\n\t\t\tconst size = config?.size ?? 4;\n\t\t\treturn `int${size}range`;\n\t\t},\n\t\tfromDriver(value) {\n\t\t\tconst parsed = range.parse(value, (value) => {\n\t\t\t\treturn parseInt(value, 10);\n\t\t\t});\n\t\t\tif (parsed.isEmpty()) {\n\t\t\t\treturn RANGE_EMPTY;\n\t\t\t}\n\t\t\treturn { lower: parsed.lower, upper: parsed.upper };\n\t\t},\n\t\ttoDriver(value) {\n\t\t\t// Using canonical form of included lower bound and excluded upper bound.\n\t\t\t// See https://www.postgresql.org/docs/current/rangetypes.html#RANGETYPES-DISCRETE\n\t\t\tconst lb = RANGE_BOUND_BRACKETS.LOWER[config?.lowerBound ?? 'inclusive'];\n\t\t\tconst ub = RANGE_BOUND_BRACKETS.UPPER[config?.upperBound ?? 'exclusive'];\n\t\t\treturn `${lb}${value.lower ?? ''},${value.upper ?? ''}${ub}`;\n\t\t},\n\t})(name, config);\n}\n\n/**\n * Implements postgres numrange type.\n *\n * @see https://www.postgresql.org/docs/current/rangetypes.html\n */\nexport function numrange<\n\tTName extends string,\n\tTConfig extends {\n\t\tlowerBound?: RangeBoundType;\n\t\tupperBound?: RangeBoundType;\n\t},\n>(name: TName, config?: TConfig) {\n\treturn customType<{\n\t\tdata: RangeValue<number>;\n\t\tdriverData: string;\n\t\tconfig: TConfig;\n\t}>({\n\t\tdataType() {\n\t\t\treturn 'numrange';\n\t\t},\n\t\tfromDriver(value) {\n\t\t\tconst parsed = range.parse(value, (value) => {\n\t\t\t\treturn parseFloat(value);\n\t\t\t});\n\t\t\tif (parsed.isEmpty()) {\n\t\t\t\treturn RANGE_EMPTY;\n\t\t\t}\n\t\t\treturn { lower: parsed.lower, upper: parsed.upper };\n\t\t},\n\t\ttoDriver(value) {\n\t\t\t// Using canonical form of included lower bound and excluded upper bound.\n\t\t\t// See https://www.postgresql.org/docs/current/rangetypes.html#RANGETYPES-DISCRETE\n\t\t\tconst lb = RANGE_BOUND_BRACKETS.LOWER[config?.lowerBound ?? 'inclusive'];\n\t\t\tconst ub = RANGE_BOUND_BRACKETS.UPPER[config?.upperBound ?? 'exclusive'];\n\t\t\treturn `${lb}${value.lower ?? ''},${value.upper ?? ''}${ub}`;\n\t\t},\n\t})(name, config);\n}\n","import { sql } from 'drizzle-orm';\n\n/**\n * SQL template true value.\n */\nexport const $true = sql<true>`'true'`;\n\n/**\n * SQL template false value.\n */\nexport const $false = sql<false>`'false'`;\n\n/**\n * SQL template boolean value.\n */\nexport function $boolean<T extends boolean>(value: T) {\n\treturn sql<T>`${value ? 'true' : 'false'}`;\n}\n\n/**\n * SQL template null value.\n */\nexport const $null = sql<null>`null`;\n\n/**\n * @example\n *\n * ```sql\n * current_timestamp();\n * ```\n */\nexport const $currentTimestamp = sql<Date>`current_timestamp`;\n","import type {\n\tAnyColumn,\n\tAnyTable,\n\tColumnsSelection,\n\tInferSelectModel,\n\tSQLChunk,\n\tSQLWrapper,\n\tSubquery,\n\tTable,\n\tTableConfig,\n\tView,\n} from 'drizzle-orm';\nimport { SQL, StringChunk, bindIfParam, isSQLWrapper, sql } from 'drizzle-orm';\nimport type { SetNonNullable } from 'type-fest';\nimport { type InferData } from '..';\nimport type { RegconfigString } from './constants';\n\n/**\n * Postgres random function.\n *\n * @example\n *\n * ```sql\n * random();\n * ```\n *\n * @returns Random number between 0 and 1.\n */\nexport function random() {\n\treturn sql<number>`random()`;\n}\n\n/**\n * Get the current time (dynamically).\n *\n * @example\n *\n * ```sql\n * now();\n * ```\n */\nexport function now() {\n\treturn sql<Date>`now()`;\n}\n\n/**\n * True if all input values are true, otherwise false.\n */\nexport function boolAnd(...expression: SQLWrapper[]) {\n\treturn sql<boolean>`bool_and(${sql.join(expression, new StringChunk(', '))})`;\n}\n\n/**\n * True if at least one input value is true, otherwise false.\n */\nexport function boolOr(...expression: SQLWrapper[]) {\n\treturn sql<boolean>`bool_or(${sql.join(expression, new StringChunk(', '))})`;\n}\n\n/**\n * SQL json_strip_nulls.\n */\nexport function jsonStripNulls<T>(json: T) {\n\treturn sql<SetNonNullable<T extends SQLWrapper ? InferData<T> : T>>`json_strip_nulls(${json})`;\n}\n\n/**\n * Aggregate sql values into an sql array.\n *\n * Input values, including nulls, concatenated into an array.\n *\n * Input arrays concatenated into array of one higher dimension (inputs must all have same\n * dimensionality, and cannot be empty or null)\n *\n * @see https://www.postgresql.org/docs/9.5/functions-aggregate.html\n *\n * @todo Implement collapsing for null array with notNull option.\n */\nexport function arrayAgg<\n\tT extends SQLWrapper,\n\t//  N extends boolean = true\n>(\n\texpression: T\n\t// { notNull = true as N }: { notNull?: N } = {}\n) {\n\treturn sql<InferData<T> | null>`array_agg(${expression})`;\n}\n\n/**\n * @see https://www.postgresql.org/docs/9.5/functions-json.html#FUNCTIONS-JSON-CREATION-TABLE\n */\nexport function toJson<T extends SQLWrapper>(anyelement: T) {\n\treturn sql<InferData<T>>`to_json(${anyelement})`;\n}\n\nexport function toJsonb<T extends SQLWrapper>(anyelement: T) {\n\treturn sql<InferData<T>>`to_jsonb(${anyelement})`;\n}\n\n/**\n * Since it is a json method, it should return an unwrapped (raw) type instead of an SQL wrapped\n * type.\n */\nexport function rowToJson<T extends Table | View | Subquery>(row: T) {\n\treturn sql<InferData<T>>`row_to_json(${row})`;\n}\n\n/**\n * Build objects using `json_build_object(k1, v1, ...kn, vn). Since it is a json method, it should\n * return an object with unwrapped value types instead of SQL wrapped types.\n */\nexport function jsonBuildObject<T extends ColumnsSelection>(shape: T) {\n\tconst chunks: SQL[] = [];\n\tObject.entries(shape).forEach(([key, value]) => {\n\t\tif (chunks.length > 0) {\n\t\t\tchunks.push(sql.raw(`,`));\n\t\t}\n\t\tchunks.push(sql.raw(`'${key}',`));\n\t\tchunks.push(sql`${value}`);\n\t});\n\treturn sql<{\n\t\t[K in keyof T]: T[K] extends SQLWrapper ? InferData<T[K]> : T[K];\n\t}>`json_build_object(${sql.join(chunks)})`;\n}\n\n/**\n * Build objects using `jsonb_build_object(k1, v1, ...kn, vn). Since it is a jsonb method, it should\n * return an object with unwrapped value types instead of SQL wrapped types.\n */\nexport function jsonbBuildObject<T extends ColumnsSelection>(shape: T) {\n\tconst chunks: SQLChunk[] = [];\n\tObject.entries(shape).forEach(([key, value]) => {\n\t\tif (chunks.length > 0) {\n\t\t\tchunks.push(sql.raw(`,`));\n\t\t}\n\t\tchunks.push(sql.raw(`'${key}',`));\n\t\tchunks.push(sql`${value}`);\n\t});\n\treturn sql<{\n\t\t[K in keyof T]: T[K] extends SQLWrapper ? InferData<T[K]> : T[K];\n\t}>`jsonb_build_object(${sql.join(chunks)})`;\n}\n\n/**\n * Aggregate sql values into an array of json objects using a combination of `json_agg` and\n * `jsonb_build_object`. Jsonb object building is used in lieu of json to allow use of distinct.\n */\nexport function jsonAggBuildObject<T extends ColumnsSelection>(\n\tshape: T,\n\t{\n\t\tdistinct = true,\n\t\t// notNull,\n\t}: {\n\t\tdistinct?: boolean;\n\t\t// notNull?: boolean;\n\t} = {}\n) {\n\treturn sql<\n\t\t{\n\t\t\t[K in keyof T]: T[K] extends SQLWrapper ? InferData<T[K]> : T[K];\n\t\t}[]\n\t>`coalesce(json_agg(${sql.raw(distinct ? 'distinct' : '')} ${jsonbBuildObject(shape)}), '${sql`[]`}')`;\n}\n\n/**\n * Aggregates name/value pairs as a JSON object; values can be null, but not names.\n *\n * Build object using `json_object_agg`. Since it is a json method, it should return an unwrapped\n * type instead of an SQL wrapped type.\n *\n * @example\n *\n * ```sql\n * json_object_agg(...)\n * ```\n *\n * @see https://www.postgresql.org/docs/9.5/functions-aggregate.html\n */\nexport function jsonObjectAgg<\n\tK extends AnyColumn,\n\tV extends SQL | SQL.Aliased | AnyTable<TableConfig>,\n\tTK extends string | number = null extends InferData<K>\n\t\t? never\n\t\t: InferData<K> extends string | number\n\t\t\t? InferData<K>\n\t\t\t: never,\n\tTV = V extends AnyTable<TableConfig> ? InferSelectModel<V> : V extends SQL ? InferData<V> : never,\n>(name: K, value: V) {\n\treturn sql<Record<TK, TV>>`json_object_agg(${name}, ${value})`;\n}\n\n/**\n * Aggregates name/value pairs as a JSON object; values can be null, but not names.\n *\n * @example\n *\n * ```sql\n * jsonb_object_agg(...)\n * ```\n *\n * @see https://www.postgresql.org/docs/9.5/functions-aggregate.html\n */\nexport function jsonbObjectAgg<\n\tK extends AnyColumn,\n\tV extends SQL | SQL.Aliased | AnyTable<TableConfig>,\n\tTK extends string | number = null extends InferData<K>\n\t\t? never\n\t\t: InferData<K> extends string | number\n\t\t\t? InferData<K>\n\t\t\t: never,\n\tTV = V extends AnyTable<TableConfig> ? InferSelectModel<V> : V extends SQL ? InferData<V> : never,\n>(name: K, value: V) {\n\treturn sql<Record<TK, TV>>`jsonb_object_agg(${name}, ${value})`;\n}\n\n/**\n * Aggregates values, including nulls, as a JSON array.\n *\n * @see https://www.postgresql.org/docs/9.5/functions-aggregate.html\n */\nexport function jsonAgg<T extends SQLWrapper, N extends boolean = true>(\n\tselection: T,\n\t{ notNull = true as N }: { notNull?: N } = {}\n): SQL<N extends true ? NonNullable<InferData<T>>[] : InferData<T>[] | [null]> {\n\tif (notNull) {\n\t\treturn sql`coalesce(json_agg(${selection}) filter (where ${selection} is not null), '[]')`;\n\t}\n\treturn sql`json_agg(${selection})`;\n}\n\n/**\n * Get the database's currently set regconfig for text-search functionalities.\n *\n * ```sql\n * get_current_ts_config();\n * ```\n */\nexport function getCurrentTsConfig() {\n\treturn sql<RegconfigString>`get_current_ts_config()`;\n}\n\n/**\n * @param regconfig Laguage configuration to use when converting source text to text search vector.\n * @param text Source text to convert into a text search vector.\n *\n *   ```sql\n *   to_tsvector();\n *   --or;\n *   plainto_tsvector();\n *   ```\n */\nexport function toTsvector(\n\ttext: unknown,\n\t{ regconfig }: { regconfig?: RegconfigString | SQLWrapper } = {}\n) {\n\tif (regconfig) {\n\t\tconst value = isSQLWrapper(regconfig) ? bindIfParam(text, regconfig) : text;\n\t\treturn sql`to_tsvector(${regconfig}, ${value})`.mapWith(String);\n\t}\n\treturn sql`to_tsvector(${text})`.mapWith(String);\n}\n\n/**\n * @param regconfig Language config for the text search query.\n * @param text Source text to convert into a text search query.\n * @param config.plain Specifies if the source text should be compared as a plain (case insensitive)\n *   query.\n *\n *   ```sql\n *   to_tsvector();\n *   ```\n */\nexport function toTsquery(\n\ttext: unknown,\n\t{\n\t\tplain = false,\n\t\tregconfig,\n\t}: {\n\t\tplain?: boolean;\n\t\tregconfig?: SQLWrapper | RegconfigString;\n\t} = {}\n) {\n\tconst start = new StringChunk(plain ? 'plainto_tsquery(' : 'to_tsquery(');\n\tconst end = new StringChunk(')');\n\tconst chunks: SQLChunk[] = [];\n\tif (regconfig) {\n\t\tchunks.push(sql`${regconfig},`);\n\t}\n\tchunks.push(isSQLWrapper(regconfig) ? sql`${bindIfParam(text, regconfig)}` : sql`${text}`);\n\treturn new SQL([start, sql.join(chunks, new StringChunk(' ')), end]).mapWith(String);\n}\n\n/**\n * The function setweight can be used to label the entries of a tsvector with a given weight, where\n * a weight is one of the letters A, B, C, or D. This is typically used to mark entries coming from\n * different parts of a document, such as title versus body. Later, this information can be used for\n * ranking of search results.\n *\n * Because to_tsvector(NULL) will return NULL, it is recommended to use coalesce whenever a field\n * might be null.\n */\nexport function setweight(tsvector: SQLWrapper, weight: string | number) {\n\tconst char = typeof weight === 'string' ? weight : String.fromCharCode(weight + 65);\n\treturn sql`setweight(${tsvector}, ${char})`.mapWith(String);\n}\n\n/**\n * Subtract arguments, producing a “symbolic” result that uses years and months, rather than just\n * days.\n *\n * @example\n *\n * ```sql\n * -- age ( timestamp, timestamp ) → interval\n * age(timestamp '2001-04-10', timestamp '1957-06-13') → 43 years 9 mons 27 days\n * ```\n */\nexport function age<TOrigin extends SQLWrapper | Date, TTarget extends SQLWrapper | Date>(\n\torigin: TOrigin,\n\ttarget: TTarget\n) {\n\treturn sql`age(${origin},${target})`.mapWith(String);\n}\n\nexport function isEmpty<T extends SQLWrapper | unknown>(range: T) {\n\treturn sql`isempty(${range})`.mapWith(Boolean);\n}\n","import type { SQLWrapper } from 'drizzle-orm';\nimport { bindIfParam, sql } from 'drizzle-orm';\n\n/**\n * Test a text search query against a ts_vector value.\n */\nexport function ts(vector: SQLWrapper, querytext: SQLWrapper) {\n\treturn sql`${vector} @@ ${bindIfParam(querytext, vector)}`;\n}\n","import { PgDialect } from 'drizzle-orm/pg-core';\n\nexport const PG_DIALECT = new PgDialect();\n\nexport type NonUndefinable<T> = T extends undefined ? never : T;\n","import { SQL, StringChunk, isSQLWrapper, sql, type AnyColumn, type SQLWrapper } from 'drizzle-orm';\nimport { customType } from 'drizzle-orm/pg-core';\nimport { INTERVAL_UNITS_ARR_ORDERED, type IntervalUnit, type RangeBoundType } from '.';\nimport type { InferData } from '..';\nimport { PG_DIALECT } from '../internals';\nimport { RANGE_BOUND_BRACKETS } from './internals';\n\nexport type RangeValue<T = void> = { upper: T | null; lower: T | null };\n\n/**\n * Get excluded column values in conflict cases. Useful for onConflictDoUpdate's set.\n *\n * @param columns Record of columns to get from the conflict's `excluded` table.\n */\nexport function toExcluded<T extends Record<string, AnyColumn>>(columns: T) {\n\treturn (Object.keys(columns) as (keyof T)[]).reduce(\n\t\t(acc, curr) => {\n\t\t\tacc[curr] = sql.raw(`excluded.${columns[curr].name}`) as SQL<InferData<T[typeof curr]>>;\n\t\t\treturn acc;\n\t\t},\n\t\t<{ [K in keyof T]: SQL<InferData<T[K]>> }>{}\n\t);\n}\n\n/**\n * Tsvector type for generated columns used notably for fuzzy string search.\n *\n * @param config.sources Array of source columns to generate the ts vector from.\n * @param config.langauge Regconfig column or sql value (conditional values, or other) to use for\n *   the vector, used for stemming. (regconfig cfgname).\n * @param config.weighted If true, concatenated sources will be weighted by their order.\n * @see https://github.com/drizzle-team/drizzle-orm/issues/247\n * @todo Implementation isn't clean. Figure out a better way to map the language name and column\n *   references, or stay up to date on support for `generatedAs()`.\n */\nexport const generatedTsvector = customType<{\n\tdata: string;\n\tconfigRequired: true;\n\tconfig: {\n\t\tsources: string[];\n\t\tlanguage: string | SQLWrapper;\n\t\tweighted?: boolean;\n\t};\n}>({\n\tdataType(config) {\n\t\tconst cfgname = isSQLWrapper(config.language)\n\t\t\t? PG_DIALECT.sqlToQuery(config.language.getSQL().inlineParams()).sql\n\t\t\t: config.language;\n\t\tif (config.weighted) {\n\t\t\tconst weighted = config.sources.map((input, index) => {\n\t\t\t\tconst weight = String.fromCharCode(index + 65);\n\t\t\t\treturn `setweight(to_tsvector(${cfgname}, coalesce(${input}, '')), '${weight}')`;\n\t\t\t});\n\t\t\treturn `tsvector generated always as (${weighted.join(' || ')}) stored`;\n\t\t} else {\n\t\t\tconst source = config.sources.join(\" || ' ' || \");\n\t\t\treturn `tsvector generated always as (to_tsvector(${config.language}, ${source})) stored`;\n\t\t}\n\t},\n});\n\n/**\n * Create an interval value by passing a value deconstructed into time units.\n */\nexport function toInterval<T extends Partial<Record<IntervalUnit, number>>>(value: T) {\n\tconst units = INTERVAL_UNITS_ARR_ORDERED.reduce(\n\t\t(acc, curr) => {\n\t\t\tif (value[curr] != null) {\n\t\t\t\tacc.push(new SQL([sql`${value[curr]}`, new StringChunk(` ${curr}`)]));\n\t\t\t}\n\t\t\treturn acc;\n\t\t},\n\t\t<SQL[]>[]\n\t);\n\treturn new SQL([\n\t\tnew StringChunk(\"(interval '\"),\n\t\tsql.join(units, new StringChunk(' ')),\n\t\tnew StringChunk(\"')\"),\n\t]).mapWith(String);\n}\n\n/**\n * Using canonical form of included lower bound and excluded upper bound. See\n * https://www.postgresql.org/docs/current/rangetypes.html#RANGETYPES-DISCRETE.\n */\nexport function toRange<\n\tconst T extends [number | undefined, number | undefined] | [Date | undefined, Date | undefined],\n>(\n\ttuple: T,\n\t{\n\t\tlowerBound = 'inclusive',\n\t\tupperBound = 'exclusive',\n\t}: { lowerBound?: RangeBoundType; upperBound?: RangeBoundType } = {}\n) {\n\tconst lb = RANGE_BOUND_BRACKETS.LOWER[lowerBound];\n\tconst ub = RANGE_BOUND_BRACKETS.UPPER[upperBound];\n\treturn sql<T>`${lb}${tuple[0]},${tuple[1]}${ub}`;\n}\n","import { z } from 'zod';\n\nexport function intrangeSchema({\n\tmin,\n\tmax,\n}: {\n\tmin?: number;\n\tmax?: number;\n} = {}) {\n\tconst baseSchema = z.number().int();\n\tconst lowerSchema = (min ? baseSchema.min(min) : baseSchema).nullable();\n\tconst upperSchema = (max ? baseSchema.max(max) : baseSchema).nullable();\n\treturn z.object({\n\t\tlower: lowerSchema,\n\t\tupper: upperSchema,\n\t});\n}\n\nexport function numrangeSchema({\n\tmin,\n\tmax,\n}: {\n\tmin?: number;\n\tmax?: number;\n} = {}) {\n\tconst lowerSchema = (min ? z.number().min(min) : z.number()).nullable();\n\tconst upperSchema = (max ? z.number().max(max) : z.number()).nullable();\n\treturn z.object({\n\t\tlower: lowerSchema,\n\t\tupper: upperSchema,\n\t});\n}\n\nfunction dateToString(date: Date, withTimezone?: boolean) {\n\tif (withTimezone) {\n\t\treturn date.toISOString();\n\t}\n\tconst tzOffset = date.getTimezoneOffset() * 60_000;\n\treturn new Date(date.valueOf() - tzOffset).toISOString().slice(0, -1);\n}\n\n/**\n * Because of typescript's peculiar handling of Infinity/-Infinity, ranges without limit need to\n * consider number members that indicate infinite bounds.\n */\nexport function tsrangeSchema<\n\tTMode extends 'date' | 'string',\n\tTData = TMode extends 'string' ? string : Date | number,\n>({\n\tmin,\n\tmax,\n\twithTimezone,\n\tmode,\n}: {\n\tmin?: Date;\n\tmax?: Date;\n\twithTimezone?: boolean;\n\tmode?: TMode;\n} = {}) {\n\tconst baseSchema = mode === 'string' ? z.coerce.date() : z.date();\n\tconst infinitySchema = mode === 'string' ? z.coerce.number() : z.number();\n\tfunction toMode(d: number | Date | null): TData {\n\t\tif (mode === 'string' && d !== null) {\n\t\t\tif (d instanceof Date) {\n\t\t\t\treturn dateToString(d, withTimezone) as TData;\n\t\t\t}\n\t\t\tif (d === -Infinity) {\n\t\t\t\treturn '-infinity' as TData;\n\t\t\t}\n\t\t\tif (d === Infinity) {\n\t\t\t\treturn 'infinity' as TData;\n\t\t\t}\n\t\t\treturn d.toString() as TData;\n\t\t}\n\t\treturn d as TData;\n\t}\n\tconst lowerSchema = (min ? baseSchema.min(min) : baseSchema.or(infinitySchema))\n\t\t.nullable()\n\t\t.transform(toMode);\n\tconst upperSchema = (max ? baseSchema.max(max) : baseSchema.or(infinitySchema))\n\t\t.nullable()\n\t\t.transform(toMode);\n\treturn z.object({\n\t\tlower: lowerSchema,\n\t\tupper: upperSchema,\n\t});\n}\n\nexport function daterangeSchema<\n\tTMode extends 'string' | 'date',\n\tTData = TMode extends 'string' ? string : Date | number,\n>({\n\tmin,\n\tmax,\n\tmode,\n}: {\n\tmin?: Date;\n\tmax?: Date;\n\tmode?: TMode;\n} = {}) {\n\tconst baseSchema = mode === 'string' ? z.coerce.date() : z.date();\n\tconst infinitySchema = mode === 'string' ? z.coerce.number() : z.number();\n\tfunction toMode(d: number | Date | null): TData {\n\t\tif (mode === 'string' && d !== null) {\n\t\t\tif (d instanceof Date) {\n\t\t\t\treturn dateToString(d) as TData;\n\t\t\t}\n\t\t\tif (d === -Infinity) {\n\t\t\t\treturn '-infinity' as TData;\n\t\t\t}\n\t\t\tif (d === Infinity) {\n\t\t\t\treturn 'infinity' as TData;\n\t\t\t}\n\t\t\treturn d.toString() as TData;\n\t\t}\n\t\treturn d as TData;\n\t}\n\tconst lowerSchema = (min ? baseSchema.min(min) : baseSchema.or(infinitySchema))\n\t\t.nullable()\n\t\t.transform(toMode);\n\tconst upperSchema = (max ? baseSchema.max(max) : baseSchema.or(infinitySchema))\n\t\t.nullable()\n\t\t.transform(toMode);\n\treturn z.object({\n\t\tlower: lowerSchema,\n\t\tupper: upperSchema,\n\t});\n}\n","import { sql } from 'drizzle-orm';\n\n/**\n * Empty record as SQL json.\n */\nexport const $emptyJsonObject = sql<object>`'{}'::json`;\n\n/**\n * Empty array as SQL json.\n */\nexport const $emptyJsonArray = sql<[never]>`'[]'::json`;\n\n/**\n * Empty SQL array (not json typed)\n */\nexport const $emptyArray = sql<[]>`'{}'`;\n\n/**\n * An array with a single null member. Typically returned when aggregation result is empty.\n */\nexport const $nullArray = sql<[null]>`'{null}'`;\n\n/**\n * Postgres value returned for empty ranges.\n */\nexport const $empty = sql<\"'empty'\" | []>`'empty'`;\n"]}